---
layout: post
title: KMP字符串匹配算法
tags: algorithm
---

{{ page.title }}
================

曾经遇到的面试题
----------------

有一个字符串"BBC ABCDAB ABCDABCDABDE"，里面是否包含另一个字符串"ABCDABD"？

BF解决法(传统字符串匹配法)
--------------------------

时间复杂度M*N，它主要是通过从现有串的第一个字符开始，与目标串第一个字符开始比较，如果相等，就对目标串与现有串的下一个字符进行比较，如此类推，如果出现不想等的情况，就立即回溯，从现有串的第二个字符重新开始比较，重复以上步骤。该算法的问题是有很多时候不用回溯到那么靠前的位置去比较，而KMP算法很好的解决了这个问题。下面是BF算法的解决代码：
	
	public static int search(String pat, String txt) {  
	    int m = pat.length();  
	    int n = txt.length();  
	    for(int i = 0; i <= n - m; i++) {  
	        int j;  
	        for(j = 0; j < m; j++) {  
	            if(txt.charAt(i + j) != pat.charAt(j))  
	                break;  
	        }  
	        if(j == m) return i;  
	    }  
	    return -1;  
	}

KMP算法
-------

时间复杂度M+N，他这么快的原因是什么，多了个前缀数组(阮一峰管他叫部分匹配表)，解决如下问题：(串与串之间上下对应)

现有串：abcabcabe                        abcabcabe                              abcabcabe

目标串：abcabe           BF算法目标串移动 abcabe           KMP算法目标串移动位置   abcabe

可以看出KMP通过前缀数组使得目标串向右多移了一些字符。 事实上前缀数组对应目标串每个字符都有个整形数值，移动位数 = 已匹配的字符数 - 对应的部分匹配值(前缀数组对应字符的值)。     

举个例子：

已知目标串的前缀数组的值为next[6]={0,0,0,1,2,0};

abcacabcabe   c!=b,右移位数=4-1=3  abcacabcabe      c!=b,右移位数=1-0=1      abcacabcabe   b!=a,右移位数1   abcacabcabe

abcabe                                abcabe                                     abcabe 						 abcabe


前缀数组的求法
--------------

首先，要了解两个概念："前缀"和"后缀"。 "前缀"指除了最后一个字符以外，一个字符串的全部头部组合；"后缀"指除了第一个字符以外，一个字符串的全部尾部组合。

"部分匹配值"就是"前缀"和"后缀"的最长的共有元素的长度。以"ABCDABD"为例，

　　－　"A"的前缀和后缀都为空集，共有元素的长度为0；

　　－　"AB"的前缀为[A]，后缀为[B]，共有元素的长度为0；

　　－　"ABC"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；

　　－　"ABCD"的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；

　　－　"ABCDA"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为"A"，长度为1；

　　－　"ABCDAB"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为"AB"，长度为2；

　　－　"ABCDABD"的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。

所以上面的目标串的前缀数组的值为next[6]={0,0,0,1,2,0};

实现思路：

如果仔细观察，可以发现构造next[i]的时候，可以利用next[i-1]的结果。假设模式已求得next[10] = 3，如下图所示：
 
000#xxx000         前缀P10
000                末尾3个字符
 
根据前缀函数的定义：next[10] = 3意味着末尾3个字符和P10的前3个字符是一样的，为求next[11]，可以直接比较第4个字符和第11个字符，如下图所示：两个#号所示，如果它们相等，则next[11] = next[10]+1 = 4,这是因为next[10] = 3保证了前缀P11和末尾4个字符的前3个字符是一样的.
 
000#xxx000#       前缀P11
000#              末尾4个字符
 
所以只需验证第4个字符和第11个字符。但如果这两个字符不想等呢？那就继续迭代，求next[11]。

算法代码：
	
	//next[7]={0,0,0,0,1,2,0}
	void compute_prefix(int *next, char *p)  
	{  
	    int     i, n, k;  
	  
	    n = strlen(p);  
	    next[1] = next[0] = 0;  
	    k = 0;      /* 第i次迭代开始之前，k表示next[i-1]的值 */    
	    for (i = 2; i <= n; i++) {  
	        for (; k != 0 && p[k] != p[i-1]; k = next[k]);  
	        if (p[k] == p[i-1]) k++;  
	        next[i] = k;  
	    }  
	} 

	//java实现
	public static int[] computePrefix(final String s) {  
	    int size = s.length();  
	    int[] result = new int[size];  
	    int j = 0;  
	  
	    for(int i = 1; i < size; i++) {  
	        while(j > 0 && s.charAt(j) != s.charAt(i)) {  
	            j = result[j - 1];  
	        }  
	        if(s.charAt(j) == s.charAt(i)) {  
	            j++;  
	        }  
	        result[i] = j;  
	    }  
	    return result;  
	}

剩余主算法(回溯部分)
--------------------

	public static void kmp(String target, String pat) {  
	    int sourceLength = pat.length();  
	    int targetLength = target.length();  
	    int[] result = computePrefix(pat);  
	    int j = 0;  
	    for(int i = 0; i < targetLength; i++) {  
	        while(j > 0 && pat.charAt(j) != target.charAt(i)) {  
	            j = result[j-1];  
	        }  
	        if(pat.charAt(j) == target.charAt(i)) {  
	            j++;  
	        }  
	        if(j == sourceLength) {  
	            System.out.println("find at index " + (i - j + 1));  
	            j = result[j-1];  
	        }  
	    }  
	} 


参考资料
--------

1.	阮一峰关于KMP算法的理解：<http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html>
2.	java实现KMP算法的讲解：<http://blog.csdn.net/v_july_v/article/details/7041827>
3.	详细算法每个过程的讲解：<http://kenby.iteye.com/blog/1025599>

{% include references.md %}
{% include pictures.md %}
