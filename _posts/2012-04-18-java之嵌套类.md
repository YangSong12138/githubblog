---
layout: post
title: java之嵌套类
tags: java
---

{{ page.title }}
================

嵌套类
------

静态成员类，也叫静态嵌套类。他是在类中使用static声明的类。静态成员类可以访问外围类的静态成员，包括外围类中声明为private的成员。

内部类
------

内部类（即非静态嵌套类）可以分为内部成员类、本地内部类和匿名内部类。通常将内部成员类简称为内部类，下面讨论的内部类即内部成员类：

与静态成员类不同的是，内部类是与外围类紧密关联的。从结构上来说，内部类类似于类的实例变量，必须存在对象，才能访问。内部类不能声明静态成员（静态变量、静态方法、静态成员类或嵌套接口）或静态初始化快。原因：从结构上来看，静态成员是不需要对象就可以直接访问的，而内部类需要依赖外部类对象，才能访问，这两者是矛盾的。从运行原理来讲，静态成员在编译时就要存入内存中，而内部类依赖外部类对象，非静态的，在编译时无法存入内存，导致他的成员变量也无法存入内存，这两者又产生了矛盾。但是也有例外，内部类可以声明值为编译时常量的final静态变量。编译器会对final类型的变量进行特殊处理，将值直接写入字节码中，而不会生成变量的符号引用。

	public class out{
		public class inner{
			final static int x = 1;
			//static所有情况
			//static int y = 12;
			//static{}
			//enum innerenum{}
			//static class inner1{}
			//interface inner3{}
			class inner2{}
		}
	}

内部类绑定外围类的原理：当创建内部类对象时，需要将外围的对象传递给内部类的构造器，用来将内部类对象绑定到外围类对象。

本地内部类
----------

本地内部类就是在方法、构造器、初始化块中声明的类。本地类不是类的成员，，从结构上类似于一个局部变量，因此本地类不能使用访问修饰符（public、protected与private），也不能使用static修饰。

	public class localclass{
		private int a = 1;
		//声明在实例初始化块
		{
			class local1{}
		}
		//声明在静态初始化块
		static{
			class local2{}
		}
		//声明在构造器中
		public localclass(){
			int x = 2;
			final int y = 3;
			class local3{
				//int z = x;不能访问非final的局部变量
				int w = y;//访问final的局部变量
				int q = a;//访问构造器所属的类的成员
			}
		}
		//声明在方法中
		public tt method(){
			class local4 implements tt{
				@Override
				public void play(){
					System.out.println("hehehhehehehehehe");
				}
			}
			return new local4();
		}
		interface tt{
			void play();
		}
	}

匿名内部类
----------

匿名类没有名字，在使用匿名类创建表达式：new X(){};时，实际上创建的是一个继承X或实现X的类型对象。因此匿名类不能继承其他类，实现其它接口。

总结
----

类型       继承其他类   由其他类继承  实现其它接口  访问修饰符  声明静态成员  绑定外围类对象
静态成员类 可以继承 	可以被继承 	  可以实现      可以声明    可以声明      未绑定
内部类     可以继承 	可以被继承 	  可以实现      可以声明    不可以声明    绑定
本地类     可以继承 	可以被继承 	  可以实现      不可以声明  不可以声明    取决于环境
匿名类     不可以继承 	不可以被继承  不可以实现    不可以声明  不可以声明    取决于环境

http://blog.csdn.net/jiangxinyu/article/details/8177326

{% include references.md %}
{% include pictures.md %}



30 5
30 5
2h 2、3
3h ssh
1h java
