---
layout: post
title: java之序列化
tags: java
---

{{ page.title }}
================

什么是java序列化
----------------

Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能。
    使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的"状态"，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量。
    除了在持久化对象时会用到对象序列化之外，当使用RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用，在本文的后续章节中将会陆续讲到。



Java 串行化技术可以使你将一个对象的状态写入一个Byte 流里，并且可以从其它地方把该Byte 流里的数据读出来，重新构造一个相同的对象。这种机制允许你将对象通过网络进行传播，并可以随时把对象持久化到数据库、文件等系统里。Java的串行化机制是RMI、EJB等技术的技术基础。用途：利用对象的串行化实现保存应用程序的当前工作状态，下次再启动的时候将自动地恢复到上次执行的状态。
序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。
序列化的实现：将需要被序列化的类实现Serializable接口，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。
2、串行化的特点：
    （1）如果某个类能够被串行化，其子类也可以被串行化。如果该类有父类，则分两种情况来考虑，如果该父类已经实现了可串行化接口。则其父类的相应字段及属性的处理和该类相同；如果该类的父类没有实现可串行化接口，则该类的父类所有的字段属性将不会串行化。
  （2）声明为static和transient类型的成员数据不能被串行化。因为static代表类的状态， transient代表对象的临时数据；
  （3）相关的类和接口：在java.io包中提供的涉及对象的串行化的类与接口有ObjectOutput接口、ObjectOutputStream类、ObjectInput接口、ObjectInputStream类。
    （1）ObjectOutput接口：它继承DataOutput接口并且支持对象的串行化，其内的writeObject()方法实现存储一个对象。ObjectInput接口：它继承DataInput接口并且支持对象的串行化，其内的readObject()方法实现读取一个对象。
    （2）ObjectOutputStream类：它继承OutputStream类并且实现ObjectOutput接口。利用该类来实现将对象存储（调用ObjectOutput接口中的writeObject()方法）。ObjectInputStream类：它继承InputStream类并且实现ObjectInput接口。利用该类来实现读取一个对象（调用ObjectInput接口中的readObject()方法）。
  对于父类的处理，如果父类没有实现串行化接口，则其必须有默认的构造函数（即没有参数的构造函数）。否则编译的时候就会报错。在反串行化的时候，默认构造函数会被调用。但是若把父类标记为可以串行化，则在反串行化的时候，其默认构造函数不会被调用。这是为什么呢？这是因为Java 对串行化的对象进行反串行化的时候，直接从流里获取其对象数据来生成一个对象实例，而不是通过其构造函数来完成。


  一、对象序列化机制 
序列化机制允许将实现序列化的Java对象转换为字节序列，这些字节序列可以被保存在磁盘上或通过网络传输，以备以后重新恢复原来的对象； 
序列化机制使得对象可以脱离程序的运行而独立存在； 
 
二、对象序列化与反序列化 
对象的序列化（Serialize）：指将一个Java对象写入IO流中； 
对象的反反序列化（Deserialize）：则指从IO流中恢复该Java对象； 
 
三、序列化实现 
如果需要让某个对象可以支持序列化机制，必须让它的类是可序列化（serializable），为了让某个类可序列化的，必须实现如下两个接口之一： 
Serializable：标记接口，无须实现任何方法，只是表明该类是可序列化的； 
Externalizable： 
所有在网络上传输的对象都应该是可序列化的，否则将会出现异常；所有需要保存到磁盘里的对象的类都必须可序列化； 
通常建议：程序创建的每个JavaBean类都实现Serializable；



Broadly, two major cases.
When your web application is distributable, the application server needs to be able to replicate sessions between servers by serializing the objects in the session.
When your web application needs to marshal domain objects over the network, for example to communicate with a remote EJB tier.


String字面常量和常量池
----------------------

java通过String常量池共享String对象。

当String对象是编译时常量(String字面常量和String表达式)，就会去常量池中寻找相等的对象。否则，会在运行时创建String对象，并分配到堆里。

equals与==
----------

默认情况下，他们两个是完全等价的，比较的是对象的地址，因为调用他的对象大部分继承自Object类，不过你可以重写equals方法，String类的equals方法就是重写过，比较的对象内容。需要牢记的是重写equals()方法时，一定要重写hashcode()方法



运算符‘+’的秘密
---------------

当使用运算符‘+’连接字符串的时候，实际上是使用临时创建的StringBuilder对象来辅助完成的。因此，循环操作进行String对象连接操作时，应该直接使用StringBuilder。

但也有例外，但‘+’连接的两个操作数都是编译时常量时，则会在编译时计算字符串的值，就不会再到运行时创建的StringBuilder对象。

注意事项
--------

方法中形参的改变无法作用于实参，但可以通过引用来修改其成员变量来修改其值。

重写equals方法的同时，一定要记得重写hashcode方法，例如，你修改了equals，然后map.get(sth)，一样的sth但还是得到空的结果，是因为要先比较hashcode，hashcode不一样所以就为null。

java序列化相关教程
------------------

1.	java串行化主要参考资料：<http://blog.csdn.net/yakihappy/article/details/3979373>
2.	jQuery设计思想：<http://blog.csdn.net/p106786860/article/details/17953223>
3.	jQuery最佳实践：<http://www.blogjava.net/jiangshachina/archive/2012/02/13/369898.html>


{% include references.md %}
{% include pictures.md %}
