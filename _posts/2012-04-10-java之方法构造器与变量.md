---
layout: post
title: java之方法、构造器与变量
tags: java
---

{{ page.title }}
================

你熟悉main方法吗？
-----------------

我们在使用main方法时通常是如下声明方法：

	public static void main(String[] args)

其实还可以：

	public static void main(String args[])

在JDK1.5以后由于添加了可变输入参数，甚至还可以：

	public static void main(String... args)

main方法与众不同地方在于，他是java虚拟机在程序启动的时候自动调用的，并且在命令行可以传递参数给main方法的args参数。

其他的表现行为与其他普通方法基本相同，可以重载，可以被调用(java反射的方式)，继承，多态，抛出异常，带有类型参数。


原来重载这么复杂
------------------

类内方法复用

很多人都知道区分重载的信息是方法形式参数对应的类型与个数。

但下面的两个方法编译器为啥会报错：

	public <T extends String> void m(T t){}
	public void m(String s){}

由此我总结了不能够用来区分重载的条件：

1. 形式参数的名称

2. 方法的返回类型

3. 方法的异常列表

4. 参数化类型(List,List<String>):参数化类型经过编译后会被删除

当多个方法构成重载时，调用的方法提供的实际参数列表与重载方法的形式参数列表 不完全匹配时，会选择哪一种重载方法？

基本数据类型：(byte->short)/(char)->int->long->float->double 选最明确的类型

引用类型：选最明确的类型

总的来说，重载的匹配先考虑非自动装箱(拆箱)与非可变参数，然后考虑自动装箱(拆箱)，最后考虑可变参数。方法的参数类型是类型变量，要先进行擦除成普通类型。

方法的重载不同于方法重写，调用哪个重载方法是根据实参的静态类型(编译时类型)决定的，与运行时实参的具体类型无关。


原来重写也这么麻烦
------------------

类间方法复用

方法重写是根据运行时引用所指向对象的实际类型来决定调用哪个方法。

在方法是静态还是实例方面，方法重写要求父类与子类的方法都是实例方法，如果其中一个方法是静态方法，则会产生编译错误，如果两个都是静态方法，没有编译错误，这种情况是方法隐藏，不是方法重写。

在方法签名方面(方法类型)，方法重写要求子类方法的签名是父类方法签名的子签名。

在方法的返回类型方面，方法重写要求子类方法返回类型是父类方法返回类型的可替换类型。

在方法的访问权限方面，方法重写要求子类方法的访问权限不能低于父类方法的访问权限，否则肯能会因为访问权限不足而无法通过父类调用子类方法。

在方法的异常列表方面，方法重写要求子类方法不能比父类方法抛出更多的受检异常，否则会在调用方法的位置无法成功捕获。

在方法的继承方面，方法重写要求子类继承父类的方法，即父类的方法在子类中必须是可访问的。否则无法重写父类的方法。

方法与成员变量的隐藏
--------------------

方法隐藏：子类与父类都是静态方法，以及上面重写的那些条件

成员变量隐藏：子类与父类具有相同的名称，与变量的类型，访问权限以及实例变量还是静态变量无关。

静态方法不能重写只能隐藏

成员变量只能重写不能隐藏

重写与隐藏的本质区别：重写是动态绑定的，根据运行时引用所指向的对象的实际类型来决定调用相关类的成员。而隐藏是静态绑定，根据编译时引用的静态类型决定调用相关类的成员。

构造器
------

构造器不是方法，也不是类的成员。因此，子类不能继承父类的构造器。

构造器是递归调用的，子类的构造器会调用父类构造器，直到调用到Object类的构造器。

构造器没有创建对象，构造器是使用new创建对象时由系统自动调用的，用来初始化类的实例成员。先创建对象再调用构造器。

当类中没有显示声明构造器时，编译器会自动添加一个无参的构造器。

protected构造器与包访问权限构造器是不同的， 前者可以在子类的构造器中使用super来调用。

成员变量的初始化
----------------

实例的成员变量与静态的成员变量的默认值相同。

局部变量没有默认值，如果未初始化，会产生编译错误。

数组类型与引用类型的默认值相同，数组变量很特殊，他即使是局部变量，如果使用了new在堆上分配空间，就会赋默认值。

变量的默认值：

boolean false，byte 0，short 0，char '\u0000'，int 0，long 0,float 0.0,double 0.0,引用(数组) null，局部变量 无默认值

初始化位置：

实例变量可以在声明处初始化，也可以在实例初始化块或构造器中初始化。静态变量可以在声明处或静态初始化块中初始化。

子类继承父类的成员变量：

对于实例变量，如果子类没有隐藏变量x，则对于同一对象，只存在一个变量x,即通过this.x与super.x访问的是同一个变量。一旦隐藏就不是同一个变量。不同子类变量值不同。

对于静态变量，如果子类没有隐藏变量x,则x由父类以及所有子类所共享，无论是通过类名（父类或子类）还是对象名（父类对象或子类对象）访问的x，都是同一个变量，如果有一个子类隐藏了x,则只有他不共享。

初始化时static修饰的变量是不能在构造器中被初始化的，因为static是隶属于类的，不隶属于某一个具体的实例对象

初始化顺序

先静态，后实例，先父类，后子类。

父类static->子类static（出现的先后顺序）->main->父类实例（包括构造器）->子类实例（包括构造器）super可以忽略

向前引用

先创建变量后初始化。

	private int x = y;
	private int y = 3;//编译不通过,向前引用

	private int x;
	private static int y = x;//编译不通过，虽然不是向前引用，但静态初始化中不能引用实例变量

	private int area = this.side * this.side;//向前引用 结果area=0
	private int side;
	public int square(){
		this.side=4
	}

不要在构造器中调用可让子类重写的方法，以免发生向前引用，正常情况下，在构造其中应该只调用声明为private或者final的方法，否则子类继承父类方法，创建父类实例时会调用子类重写方法，而非父类方法。

	public class All{
		public static void main(String[] args){
			B b=new B();
			b.xixi();
		}
	}
	public class A{
		public A(){
			xixi();
		}
		public void xixi(){
			System.out.println("1");
		}
	}
	public class B extends A{
		public void xixi(){
			System.out.println("2");
		}
	}

向前引用的例外：

当变量x满足：final修饰，声明处初始化，初始化x的表达式（值）是常量表达式。会最先得到初始化！

注意事项
--------

方法中形参的改变无法作用于实参，但可以通过引用来修改其成员变量来修改其值。

重写equals方法的同时，一定要记得重写hashcode方法，例如，你修改了equals，然后map.get(sth)，一样的sth但还是得到空的结果，是因为要先比较hashcode，hashcode不一样所以就为null。

{% include references.md %}
{% include pictures.md %}
